{
  "uid": "0CTF2021Quals/cloudpass_task",
  "url": "https://cn.bing.com/search?q=0CTF2021Quals-cloudpass_task",
  "tags": [
    "py"
  ],
  "title": "cloudpass_task",
  "statement": "#!/usr/bin/python3\nimport os\nimport socketserver\nimport random\nimport signal\nimport string\nimport struct\nfrom hashlib import sha256\nimport secrets\nimport pykeepass\n\nfrom flag import flag\n\nMAXSIZE = 0x2000\n\nclass Task(socketserver.BaseRequestHandler):\n    def proof_of_work(self):\n        proof = ''.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)])\n        digest = sha256(proof.encode('latin-1')).hexdigest()\n        self.request.send(str.encode(\"sha256(XXXX+%s) == %s\\n\" % (proof[4:],digest)))\n        self.request.send(str.encode('Give me XXXX:'))\n        x = self.request.recv(10).decode()\n        x = x.strip()\n        xx = x+proof[4:]\n        if len(x) != 4 or sha256(xx.encode('latin-1')).hexdigest() != digest:\n            return False\n        return True\n\n    def askfor(self, msg):\n        self.request.sendall(msg)\n        return self.request.recv(0x20).strip().decode('latin-1')\n\n    def recvint(self):\n        try:\n            return int(self.request.recv(10))\n        except:\n            return 0\n\n    def recvblob(self):\n        self.request.sendall(b\"size: \")\n        sz = self.recvint()\n        assert sz < MAXSIZE\n        self.request.sendall(b\"blob(hex): \")\n        sz = sz*2+1\n        r = sz\n        res = b''\n        while r>0:\n            res += self.request.recv(r)\n            r = sz - len(res)\n        return bytes.fromhex(res.strip().decode('latin-1'))\n\n    def prepared(self):\n        client_ip = self.client_address[0]\n        dname = sha256(client_ip.encode('latin-1')).hexdigest()\n        self.d = os.path.join(\"/tmp\", dname)\n        os.makedirs(self.d, exist_ok=True)\n        self.f = os.path.join(self.d, \"a.kdbx\")\n\n    def handle(self):\n        signal.alarm(20)\n        if not self.proof_of_work():\n            return\n        signal.alarm(20)\n        self.request.sendall(b\"Welcome to our cloud password storage service.\\nNotice that storage size is strictly limited for free trial >_<\\n\")\n        self.prepared()\n        self.request.sendall(b\"master password: \")\n        password = self.request.recv(0x40).strip().decode('latin-1')\n        if not os.path.exists(self.f):\n            answer = self.askfor(b\"Do you already have a database to import? (y/N) \")\n            if answer[0] == 'y':\n                file = self.recvblob()\n                with open(self.f, 'wb') as f:\n                    f.write(file)\n            else:\n                pykeepass.create_database(self.f, password)\n        try:\n            db = pykeepass.PyKeePass(self.f, password)\n        except:\n            self.request.sendall(b\"[error] Invalid master password!\\n\")\n            self.request.sendall(b\"We never store your master password for safety, and cannot help you recover it :(\\n\")\n            answer = self.askfor(b\"Do you want to delete your database? (y/N) \")\n            if answer[0] == 'y':\n                os.remove(self.f)\n            self.request.close()\n            return\n        for _ in range(0x100):\n            self.request.sendall(b\"> \")\n            cmd = self.request.recv(0x20).strip()\n            if cmd == b\"add_entry\":\n                gn = self.askfor(b\"dest group: \")\n                g = db.root_group if gn == \"\" else db.find_groups_by_name(gn, first=True)\n                t = self.askfor(b\"title: \")\n                u = self.askfor(b\"username: \")\n                p = self.askfor(b\"password: \")\n                db.add_entry(g, t, u, p)\n            elif cmd == b\"add_group\":\n                gn = self.askfor(b\"dest group: \")\n                g = db.root_group if gn == \"\" else db.find_groups_by_name(gn, first=True)\n                n = self.askfor(b\"name: \")\n                db.add_group(g, n)\n            elif cmd == b\"add_binary\":\n                blob = self.recvblob()\n                db.add_binary(blob)\n            elif cmd == b\"find_entries\":\n                t = self.askfor(b\"title: \")\n                res = db.find_entries_by_title(t)\n                if len(res) > 0:\n                    self.request.sendall(str(res[0]).encode('latin-1')+b'\\n')\n            elif cmd == b\"find_groups\":\n                n = self.askfor(b\"name: \")\n                res = db.find_groups_by_name(n)\n                if len(res) > 0:\n                    self.request.sendall(str(res[0]).encode('latin-1')+b'\\n')\n            elif cmd == b\"gimme_flag\":\n                db.add_entry(db.root_group, \"flag\", \"0ops\", flag)\n                db.password = secrets.token_hex(32)\n            elif cmd == b\"list_entries\":\n                self.request.sendall(str(db.entries).encode('latin-1')+b'\\n')\n            elif cmd == b\"list_groups\":\n                self.request.sendall(str(db.groups).encode('latin-1')+b'\\n')\n            elif cmd == b\"list_binaries\":\n                self.request.sendall(str(db.binaries).encode('latin-1')+b'\\n')\n            elif cmd == b\"leave\":\n                answer = self.askfor(b\"Do you need to backup your database elsewhere? (y/N) \")\n                if answer[0] == 'y':\n                    with open(self.f, 'rb') as f:\n                        cont = f.read()\n                    self.request.sendall(cont.hex().encode('latin-1')+b'\\n')\n                break\n            else:\n                break\n            db.save()\n            if os.stat(self.f).st_size > MAXSIZE:\n                self.request.sendall(b\"[error] Filesize limit exceeded!\")\n                os.remove(self.f)\n                break\n        self.request.close()\n\nclass ForkedServer(socketserver.ForkingTCPServer, socketserver.TCPServer):\n    pass\n\nif __name__ == \"__main__\":\n    HOST, PORT = '0.0.0.0', 10001\n    server = ForkedServer((HOST, PORT), Task)\n    server.allow_reuse_address = True\n    server.serve_forever()\n",
  "source": "0CTF2021Quals",
  "vjudge": true
}